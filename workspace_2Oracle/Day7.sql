-- MEMBER 테이블을 생성하여
-- 사용자 정보를 받을 수 있는 테이블 객체를 만들되,
-- 회원 번호는 NUMBER형태로 기본키 설정하고,
-- 회원 아이디는 중복 불가에 필수 입력 사항으로,
-- 회원 비밀번호는 필수 입력 사항,
-- 회원 이름, 성별('M', 'F'),
-- 회원 연락처, 회원 생년월일 정보를
-- 받을 수 있는 컬럼을 가진 테이블을 생성하시오.
-- 단, 각 컬럼의 길이는 직접 판단하고,
-- 위에 생성된 테이블 기준으로
-- 회원 정보를 최소 5개 이상 삽입하여 확인하시오.

CREATE TABLE MEMBER(
	M_NO NUMBER CONSTRAINT PK_MEMBER PRIMARY KEY,
	M_ID VARCHAR2(15) NOT NULL UNIQUE,
	M_PWD VARCHAR2(30) NOT NULL,
	M_NAME VARCHAR2(15),
	M_GENDER CHAR(1) CHECK(M_GENDER IN('M','F')),
	M_MAIL VARCHAR2(30),
	M_PHONE VARCHAR2(14),
	M_BIRTH DATE
);

COMMENT ON COLUMN MEMBER.M_NO IS '회원번호';
COMMENT ON COLUMN MEMBER.M_ID IS '회원아이디';

INSERT INTO MEMBER
VALUES(1,'USER01','PASS01','LEE','M','LEE@KH.OR.KR','010-1111-2222', TO_DATE(101010,'RRMMDD'));

SELECT * FROM MEMBER;


-- FOREIGN KEY --
-- 외래키, 외부키, 참조키 라고 한다.
-- 다른 테이블의 컬럼값을 참조(REFERENCE)하여 참조하는 테이블의 값만 허용
-- FOREIGN KEY 제약조건을 통해 다른 테이블과의 관계(RELATIONSHIP)가 형성 된다.

-- 컬럼레벨 일 경우
-- 컬럼명  자료형(길이)   [CONSTRAINT  제약조건명 ] REFERENCES 참조할 테이블명 [(참조할 컬럼명)] [삭제옵션]
-- 테이블 레벨 일 경우
-- [CONSTRAINT 제약조건명] FOREIGN KEY(적용할 컬럼명) REFERENCES 참조할 테이블명[(참조할 컬럼명)] [삭제옵션]

DROP TABLE USER_GRADE;

CREATE TABLE USER_GRADE(
	GRADE_CODE NUMBER PRIMARY KEY,
	GRADE_NAME VARCHAR2(30) NOT NULL
);

INSERT INTO USER_GRADE VALUES(1, '일반 회원');
INSERT INTO USER_GRADE VALUES(2, 'VIP');
INSERT INTO USER_GRADE VALUES(3, 'VVIP');
INSERT INTO USER_GRADE VALUES(4, 'VVVIP');

SELECT * FROM USER_GRADE;

CREATE TABLE USER_FOREIGN_KEY(
	USER_NO NUMBER PRIMARY KEY,
	USER_ID VARCHAR2(20),
	USER_PWD VARCHAR2(20),
	USER_NAME VARCHAR2(15),
	GENDER CHAR(1) CHECK(GENDER IN ('M','F')),
	GRADE_CODE NUMBER,
	CONSTRAINT FK_GRADE_CODE FOREIGN KEY (GRADE_CODE) REFERENCES USER_GRADE(GRADE_CODE)
);
INSERT INTO USER_FOREIGN_KEY VALUES(1,'123','321','LEE','F',2);
INSERT INTO USER_FOREIGN_KEY VALUES(2,'ABC','ABC1','KIM','F',4);
INSERT INTO USER_FOREIGN_KEY VALUES(3,'456','456','CHOI','M',1);
INSERT INTO USER_FOREIGN_KEY VALUES(4,'DEF','DEF1','HONG','F',3);
INSERT INTO USER_FOREIGN_KEY VALUES(5,'QWE','QWE1','PARK','M',1);

SELECT * FROM USER_FOREIGN_KEY;
--ORA-02291: integrity constraint (TEST.FK_GRADE_CODE) violated - parent key not found
INSERT INTO USER_FOREIGN_KEY VALUES(6,'QWE','ABC','JANG','M',10);

SELECT *
FROM USER_FOREIGN_KEY 
JOIN USER_GRADE USING(GRADE_CODE);

-- 삭제옵션
--ORA-02292: integrity constraint (TEST.FK_GRADE_CODE) violated - child record found
DELETE FROM USER_GRADE WHERE GRADE_CODE = 4;


-- 참조하고 있는 원본 테이블의 컬럼 값이 삭제될때
-- 참조한 값을 어떻게 처리할 것인지 설정하는 옵션         
-- 1. 부모 컬럼을 삭제할 때 자식을 NULL로 변경하기
-- ON DELETE SET NULL
-- 2. 부모 컬럼을 삭제할 때 관련된 자식도 함께 삭제하기
-- ON DELETE CASCADE

--ORA-02449: unique/primary keys in table referenced by foreign keys
DROP TABLE USER_GRADE;
DROP TABLE USER_FOREIGN_KEY;



CREATE TABLE USER_GRADE(
	GRADE_CODE NUMBER PRIMARY KEY,
	GRADE_NAME VARCHAR2(30) NOT NULL
);

INSERT INTO USER_GRADE VALUES(1, '일반 회원');
INSERT INTO USER_GRADE VALUES(2, 'VIP');
INSERT INTO USER_GRADE VALUES(3, 'VVIP');
INSERT INTO USER_GRADE VALUES(4, 'VVVIP');

SELECT * FROM USER_GRADE;

-- 연습 1. USER_FOREIGN_KEY + ON DELETE SET NULL
CREATE TABLE USER_FOREIGN_KEY(
	USER_NO NUMBER PRIMARY KEY,
	USER_ID VARCHAR2(20),
	USER_PWD VARCHAR2(20),
	USER_NAME VARCHAR2(15),
	GENDER CHAR(1) CHECK(GENDER IN ('M','F')),
	GRADE_CODE NUMBER,
	CONSTRAINT FK_GRADE_CODE FOREIGN KEY (GRADE_CODE) 
	REFERENCES USER_GRADE(GRADE_CODE) ON DELETE SET NULL
);
INSERT INTO USER_FOREIGN_KEY VALUES(1,'123','321','LEE','F',2);
INSERT INTO USER_FOREIGN_KEY VALUES(2,'ABC','ABC1','KIM','F',4);
INSERT INTO USER_FOREIGN_KEY VALUES(3,'456','456','CHOI','M',1);
INSERT INTO USER_FOREIGN_KEY VALUES(4,'DEF','DEF1','HONG','F',3);
INSERT INTO USER_FOREIGN_KEY VALUES(5,'QWE','QWE1','PARK','M',1);

COMMIT;
SELECT * FROM USER_FOREIGN_KEY;

DELETE FROM USER_GRADE WHERE GRADE_CODE=4;

SELECT * FROM USER_FOREIGN_KEY;
SELECT * FROM USER_GRADE;

ROLLBACK;

-- 연습 2. USER_FOREIGN_KEY + ON DELETE CASCADE
-- 자식 테이블의 데이터 삭제된다.

DROP TABLE USER_FOREIGN_KEY;

CREATE TABLE USER_FOREIGN_KEY(
	USER_NO NUMBER PRIMARY KEY,
	USER_ID VARCHAR2(20),
	USER_PWD VARCHAR2(20),
	USER_NAME VARCHAR2(15),
	GENDER CHAR(1) CHECK(GENDER IN ('M','F')),
	GRADE_CODE NUMBER,
	CONSTRAINT FK_GRADE_CODE FOREIGN KEY (GRADE_CODE) 
	REFERENCES USER_GRADE(GRADE_CODE) ON DELETE CASCADE
);
INSERT INTO USER_FOREIGN_KEY VALUES(1,'123','321','LEE','F',2);
INSERT INTO USER_FOREIGN_KEY VALUES(2,'ABC','ABC1','KIM','F',4);
INSERT INTO USER_FOREIGN_KEY VALUES(3,'456','456','CHOI','M',1);
INSERT INTO USER_FOREIGN_KEY VALUES(4,'DEF','DEF1','HONG','F',3);
INSERT INTO USER_FOREIGN_KEY VALUES(5,'QWE','QWE1','PARK','M',1);

SELECT * FROM USER_FOREIGN_KEY;

COMMIT;
DELETE FROM USER_GRADE WHERE GRADE_CODE=2;
SELECT * FROM USER_GRADE;
SELECT * FROM USER_FOREIGN_KEY;

ROLLBACK;


-- SUBQUERY를 활용한 테이블 생성 --
-- 컬럼명, 데이터 타입, 값, NOT NULL 은 복사된다.
-- 하지만 다른 제약조건은 복사되지 않는다.
SELECT * FROM employee;

CREATE TABLE EMPLOYEE_COPY
AS SELECT * FROM EMPLOYEE;

SELECT * FROM EMPLOYEE_COPY;

-- 테이블의 형식만 복사하기
CREATE TABLE EMPLOYEE_COPY2
AS SELECT * FROM EMPLOYEE WHERE 1 = 2;

SELECT * FROM EMPLOYEE_COPY2;


-- 각 컬럼에 값을 기록하지 않을 경우 기본값 설정하기
CREATE TABLE DEFAULT_TABLE(
	DATA_COL1 VARCHAR2(30) DEFAULT '없음',
	DATA_COL2 DATE DEFAULT SYSDATE
);

INSERT INTO DEFAULT_TABLE VALUES(DEFAULT, DEFAULT);
SELECT * FROM DEFAULT_TABLE;


-- 제약조건을 테이블 생성 후에 추가하는 DDL
-- ALTER 사용하기
SELECT * FROM USER_CONSTRAINTS 
WHERE TABLE_NAME = 'EMPLOYEE';

--[사용형식]
--ALTER TABLE 테이블명 ADD PRIMARY KEY(컬럼명)
--ALTER TABLE 테이블명 ADD FOREIGN KEY(컬럼명) REFERENCES 테이블명(컬럼명)
--ALTER TABLE 테이블명 ADD UNIQUE(컬럼명)
--ALTER TABLE 테이블명 ADD CHECK( 조건식 )
--ALTER TABLE 테이블명 MODIFY 컬럼명 NOT NULL

--문제
-- EMPLOYEE 테이블에서
--   DEPT_CODE에 외래키 제약 조건 추가
--   참조할 컬럼은 DEPARTMENT.DEPT_ID
--   JOB_CODE에 외래키 제약 조건 추가
--   참조할 컬럼은 JOB.JOB_CODE
--   SAL_LEVEL에 외래키 제약 조건 추가
--   참조할 컬럼은 SAL_GRADE.SAL_LEVEL
--   ENT_YN 컬럼에 CHECK 제악조건 추가 ('Y', 'N') 대소문자 구분
--   SALARY 컬럼에 CHECK 제약조건 추가 (무조건 양수 기입)
--   EMP_NO 컬럼에 UNIQUE 제약 조건 추가
-- DEPARTMENT 테이블에서
--   LOCATION_ID에 외래키 제약조건 추가
--   LOCATION 테이블의 기본키 컬럼
-- LOCATION 테이블에서 NATIONAL_CODE 외래키 제약 조건 추가
--   NATIONAL 테이블의 기본키 컬럼

-- 다 만든 후에 USER_CONTRAINTS 에서
-- 3개의 테이블 조회하기

ALTER TABLE EMPLOYEE ADD FOREIGN KEY(DEPT_CODE) REFERENCES DEPARTMENT;
ALTER TABLE EMPLOYEE ADD FOREIGN KEY(JOB_CODE) REFERENCES JOB;
ALTER TABLE EMPLOYEE ADD FOREIGN KEY(SAL_LEVEL) REFERENCES SAL_GRADE;

ALTER TABLE EMPLOYEE ADD CHECK(ENT_YN IN('Y','N'));
ALTER TABLE EMPLOYEE ADD CHECK(SALARY > 0);
ALTER TABLE EMPLOYEE ADD UNIQUE(EMP_NO);

ALTER TABLE DEPARTMENT ADD FOREIGN KEY(LOCATION_ID) REFERENCES LOCATION;
ALTER TABLE LOCATION ADD FOREIGN KEY(NATIONAL_CODE) REFERENCES NATIONAL;

SELECT C1.TABLE_NAME, C1.CONSTRAINT_NAME, CONSTRAINT_TYPE, COLUMN_NAME, SEARCH_CONDITION
FROM USER_CONSTRAINTS C1
JOIN USER_CONS_COLUMNS C2 ON(C1.TABLE_NAME = C2.TABLE_NAME
							AND C1.CONSTRAINT_NAME = C2.CONSTRAINT_NAME)
WHERE C1.TABLE_NAME IN ('EMPLOYEE', 'DEPARTMENT','LOCATION');


--DML(데이터 조작 언어)
-- INSERT , UPDATE , DELETE , SELECT(DQL)
-- [ CRUD ]
-- C(CREATE) 	: INSERT
-- R(READ)		: SELECT	
-- U(UPDATE)	: UPDATE
-- D(DELETE)	: DELETE

-- INSERT : 새로운 행을 특정 테이블에 추가하는 명령어
--	         실행후에는 테이블의 행의 개수가 증가

--[사용형식]
-- 1. 특정 컬럼에 값을 추가하는 방법
-- INSERT INTO 테이블명(컬럼명, . . . . ) VALUES(값1, .... );
-- 2. 모든 컬럼에 값을 추가하는 방법
-- INSERT INTO 테이블명 VALUES(값, 값, ....);

SELECT * FROM EMPLOYEE WHERE 1=2;
-- 컬럼명을 명시하여 데이터 추가
INSERT INTO EMPLOYEE(EMP_ID, EMP_NAME, EMP_NO, EMAIL, PHONE, DEPT_CODE, JOB_CODE, 
					 SAL_LEVEL, SALARY, BONUS, MANAGER_ID, HIRE_DATE, ENT_DATE, ENT_YN)
VALUES(500, '추민석', '700101-1234556', 'choo@kh.or.kr', '01011112222', 'D1','J7',
	   'S4', 3100000, 0.1, '200',SYSDATE, NULL, DEFAULT);

SELECT * FROM EMPLOYEE WHERE EMP_NAME='추민석';

-- 컬럼을 생략하고 사용하기(모든 컬럼에 값 추가)
INSERT INTO EMPLOYEE
VALUES(900, '박응서','510101-1234567','park@kh.or.kr','01022334444','D1','J7','S3',430000000,
	   0.2, '200',SYSDATE, NULL, DEFAULT);

SELECT * FROM EMPLOYEE;

--지금까지 변경된 내용을 실제 데이터베이스에 반영하겠다. 
COMMIT;

-- INSERT + SUBQUERY
-- VALUES 대신 값을 지정하여 추가 가능
CREATE TABLE EMP_01(
	EMP_ID NUMBER,
	EMP_NAME VARCHAR2(20),
	DEPT_TITLE VARCHAR2(40)
);
INSERT INTO EMP_01 (
		SELECT EMP_ID, EMP_NAME, DEPT_TITLE
		FROM EMPLOYEE
		LEFT JOIN DEPARTMENT ON(DEPT_CODE = DEPT_ID)
);

SELECT * FROM EMP_01;

--
CREATE TABLE EMP_DEPT_D1
AS SELECT EMP_ID, EMP_NAME, DEPT_CODE, HIRE_DATE
	FROM EMPLOYEE
	WHERE 1=2;

-- EMPLOYEE 테이블에서 D1부서에 근무하는 직원들의
-- 사번, 이름, 부서코드, 입사일을 조회하여
-- EMP_DEPT_D1 테이블에 추가
INSERT INTO EMP_DEPT_D1(
	SELECT EMP_ID, EMP_NAME, DEPT_CODE, HIRE_DATE
	FROM EMPLOYEE
	WHERE DEPT_CODE = 'D1'
);
SELECT * FROM EMP_DEPT_D1;

COMMIT;

CREATE TABLE EMP_OLD
AS SELECT EMP_ID, EMP_NAME, HIRE_DATE, SALARY
   FROM EMPLOYEE 
   WHERE 1=2;
CREATE TABLE EMP_NEW
AS SELECT EMP_ID, EMP_NAME, HIRE_DATE, SALARY
   FROM EMPLOYEE 
   WHERE 1=2;

-- EMPLOYEE 테이블에서
-- 입사일 기준 2000년 1월 1일 이전 입사자들의 사번, 이름, 입사일, 급여를 EMP_OLD에 추가하고
--                    그 이후 입사자들의 사번, 이름, 입사일, 급여를 EMP_NEW에 추가하여 처리
INSERT ALL
	WHEN HIRE_DATE < '2000/01/01'
	THEN INTO EMP_OLD VALUES(EMP_ID, EMP_NAME, HIRE_DATE, SALARY)
	WHEN HIRE_DATE >= '2000/01/01'
	THEN INTO EMP_NEW VALUES(EMP_ID, EMP_NAME, HIRE_DATE, SALARY)
SELECT * FROM EMPLOYEE;

SELECT * FROM EMP_OLD;
SELECT * FROM EMP_NEW;

COMMIT;

--UPDATE : 해당 테이블의 데이터를 수정 하는 명령어
--[사용형식]
--UPDATE 테이블명  SET 컬럼명 = 변경할값
--[WHERE 컬럼명 비교연산저 비교값]

CREATE TABLE DEPT_COPY
AS SELECT * FROM DEPARTMENT;

SELECT * FROM DEPT_COPY;

-- D9부서를 총무부->전략기회부 

COMMIT;
UPDATE DEPT_COPY 
SET DEPT_TITLE = '전략기획부';

ROLLBACK;

UPDATE DEPT_COPY 
SET DEPT_TITLE='전략기획부'
WHERE DEPT_ID = 'D9';

SELECT * FROM DEPT_COPY;

COMMIT;
SELECT * FROM EMPLOYEE;

--EMPLOYEE 테이블에서 사번이 200,201,214 인 사원의 주민등록번호 앞자리를
--각각 621130, 630126, 850507로 수정해보자.

SELECT * FROM EMPLOYEE;
-- UPDATE문 3개 작성
UPDATE EMPLOYEE SET EMP_NO = '621130'||SUBSTR(EMP_NO,7)
WHERE EMP_ID =200;
UPDATE EMPLOYEE SET EMP_NO = '630126'||SUBSTR(EMP_NO,7)
WHERE EMP_ID = 201;
UPDATE EMPLOYEE SET EMP_NO = '850507'||SUBSTR(EMP_NO,7)
WHERE EMP_ID=214;

-- UPDATE + SUBQUERY
-- 여러 행을 변경하거나, 여러 컬럼의 값을 변경하고자 할 때 서브 쿼리를 사용하여 UPDATE를 작성할 수 있다.
-- UPDATE 테이블 SET 컬럼명 = (서브쿼리);
CREATE TABLE EMP_SALARY
AS SELECT EMP_ID, EMP_NAME, DEPT_CODE, SALARY, BONUS
   FROM EMPLOYEE ;

SELECT * FROM EMP_SALARY 
WHERE EMP_NAME IN('유재식','방명수');

-- 유재식 사원과 같은 급여와 보너스를 받고 싶어하는 방명수 사원의 
-- 급여와 보너스를 유재식 사원과 같은 값으로 변경하는 쿼리 작성

-- 단일 행 서브쿼리 활용
UPDATE EMP_SALARY
SET SALARY = (SELECT SALARY FROM EMP_SALARY WHERE EMP_NAME='유재식'),
    BONUS = (SELECT BONUS FROM EMP_SALARY WHERE EMP_NAME = '유재식')
WHERE EMP_NAME = '방명수';

SELECT * FROM EMP_SALARY 
WHERE EMP_NAME IN('유재식','방명수');


--'노옹철','전형돈','정중하','하동운' 의 유재식 사원과 같은 급여, 보너스로 수정
-- 단, 다중열 서브쿼리로 구현

UPDATE EMP_SALARY 
SET (SALARY, BONUS) = (SELECT SALARY, BONUS
					   FROM EMP_SALARY
					   WHERE EMP_NAME='유재식')
WHERE EMP_NAME IN ('노옹철','정중하','전형돈','하동운');

SELECT * FROM EMP_SALARY 
WHERE EMP_NAME IN('유재식','방명수','노옹철','전형돈','정중하','하동운');


--UPDATE시 변경할 값이 제약조건에 위배되지 않아야 한다.
--integrity constraint (TEST.SYS_C007127) violated - parent key not found
-- 외래키 제약조건 위배
UPDATE EMPLOYEE 
SET DEPT_CODE = 'D0'
WHERE DEPT_CODE = 'D6';

--ORA-01407: cannot update ("TEST"."EMPLOYEE"."EMP_ID") to NULL
-- NOT NULL 제약조건 위배
UPDATE EMPLOYEE 
SET EMP_ID = NULL
WHERE EMP_ID = 200;

SELECT * FROM EMPLOYEE;

--ORA-00001: unique constraint (TEST.SYS_C007131) violated
UPDATE EMPLOYEE 
SET EMP_NO = '630126-1548654'
WHERE EMP_NAME='선동일';















